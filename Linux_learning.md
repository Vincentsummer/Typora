# Linux学习笔记

## 用户态与内核态

在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。Intel的CPU将特权级别分为4个级别：RING0，RING1，RING2，RING3。

linux的内核是一个有机的整体。每一个用户进程运行时都好像有一份内核的拷贝，每当用户进程使用系统调用时，都自动地将运行模式从用户级转为内核级，此时进程在内核的地址空间中运行。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, 如上所提到的intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。

![内核态](/home/vincent/Typora/Linux_learning.assets/内核态.gif)

**操作系统需要两种CPU状态：**

- 内核态（Kernel Mode）：运行操作系统程序。

- 用户态（User Mode）：运行用户程序。

**指令划分：**

- 特权指令：只能由操作系统使用、用户程序不能使用的指令。  eg：启动I/O，内存清零，修改程序状态字，设置时钟，允许/禁止终端，停机。

- 非特权指令：用户程序可以使用的指令。  eg：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）。

**特权级别：**

- **特权环：R0、R1、R2和R3**。R0相当于内核态，R3相当于用户态；不同级别能够运行不同的指令集合；

**CPU状态之间的转换：**

- **用户态--->内核态：**唯一途径是通过中断、异常、陷入机制（访管指令）。

- **内核态--->用户态：**设置程序状态字PSW。

**用户态到内核态的切换：**

- 系统调用

**这是用户态进程主动要求切换到内核态的一种方式**，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

- 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 

- 外围设备的中断

**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

## 进程与线程

#### 进程

**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。**进程是一种抽象的概念，从来没有统一的标准定义。**进程一般由程序，数据集合和进程控制块三部分组成**。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

- 并发性：任何进程都可以同其他进行一起并发执行；

- 独立性：进程是系统进行资源分配和调度的一个独立单位；

- 结构性：进程由程序，数据和进程控制块三部分组成。

#### 线程

在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

#### 进程与线程的区别

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多。

#### 为何不使用多进程而是使用多线程？

线程廉价，线程启动比较快，退出比较快，对系统资源的冲击也比较小。而且线程彼此分享了大部分核心对象(File Handle)的拥有权如果使用多重进程，但是不可预期，且测试困难。

#### 进程调度策略

**先来先服务调度算法**

先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

**短作业(进程)优先调度算法**

短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

**高优先权优先调度算法**

为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。

- **非抢占式优先权算法**：在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。
- **抢占式优先权调度算法**：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程 $i$ 时，就将其优先权 $P_i$ 与正在执行的进程 $j$ 的优先权 $P_j$ 进行比较。如果 $P_i≤P_j$，原进程 $P_j$ 便继续执行；但如果是 $P_i>P_j$，则立即停止 $P_j$ 的执行，做进程切换，使 $i$ 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

优先级倒置现象：优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。

优先级反转案例解释：不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。

优先级倒置解决方案：

- 设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。
- 优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。
- 临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。

**高响应比优先调度算法**

在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 $a$ 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。 在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。

**时间片轮转法**

在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。

**多级反馈队列调度算法**

前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。

1. 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。
2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。
3. 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

#### 批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？

- 批处理系统常用调度算法：先来先服务，最短作业优先，最短剩余时间优先，响应比最高者优先。
- 分时系统调度算法：轮转调度，优先级调度，多级队列调度，彩票调度。
- 实时系统调度算法：单比率调度，限期调度，最少裕度法。

## 进程间通信方式

### IPC介绍

**进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间共享消息的一种通信方式**。消息(message)是发送进程形成的一个消息块，将消息内容传送给接收进程。IPC机制是消息从一个进程的地址空间拷贝到另一个进程的地址空间。

进程通信的目的：

- 数据传输
  一个进程需要将其数据发送给另一进程，发送的数据量在一个字节到几M字节之间。
- 共享数据
  多个进程操作共享数据。
- 事件通知
  一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- 资源共享
  多个进程之间共享同样的资源。**为了作到这一点，需要内核提供锁和同步机制**。
- 进程控制
  有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### linux使用的进程间通信方式

1. 管道（pipe）,流管道(s_pipe)和有名管道（FIFO）
2. 消息队列
3. **共享内存**
4. **信号量**
5. **套接字（socket)**

#### 管道（Pipe）

管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。

特点：

- 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
- 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

#### 命名管道（FIFO）

FIFO，也称为命名管道，它是一种文件类型。

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。

特点：

- FIFO可以在无关的进程之间交换数据，与无名管道不同。
- FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

#### 消息队列（message queue）

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。 消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。

特点：

- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
- 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
- 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

#### 信号量（semaphore）

信号量与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

特点：

- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
- 支持信号量组。

#### 共享内存（Shared Memory）

共享内存，指两个或多个进程共享一个给定的存储区。

将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。

特点：

- 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
- 因为多个进程可以同时操作，所以需要进行同步。
- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

#### 套接字（socket）

套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

### 总结

#### 几种通信方式的比较

1. 管道：速度慢，容量有限，只有父子进程能通讯。
2. FIFO：任何进程间都能通讯，但速度慢。
3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
4. 信号量：不能传递复杂消息，只能用来同步。
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

#### 进程间通信方式的选择

- PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，**这两种方式通常适用于两个进程间的通信**。
- 共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于多进程间的通信。
- 其他考虑用socket。主要应用在**分布式开发中**。

## linux常用命令总结（Ubuntu）

### 常用软件更新命令

- apt-get install package 安装package
- apt-get install package --reinstall 重新安装包package
- apt-get -f install 修复安装
- apt-get update 更新源
- apt-get upgrade 更新已安装的包
- apt-get dist-upgrade 升级系统
- apt-get remove package 删除包
- apt-get remove package --purge 删除包，包括配置文件等
- apt-get clean 清理所有软件缓存
- sudo apt-get autoclean 清理旧版本软件缓存
- sudo apt-get autoremove 清理系统不再使用的孤立软件

### 查看Ubuntu系统版本信息

- cat /proc/version	查看linux内核、gcc编译器和Ubuntu版本号
- uname -a	显示linux的内核版本和系统位数
- lsb_release -a	查看ubuntu发行版本号
- dpkg --get-selections|grep linux 查看当前系统所有内核
- sudo apt-get remove 【内核名】删除内核

### 进程相关命令

- ps [pid]	查看进程（特定pid的进程）
- ps a	显示现行终端机下的所有程序，包括其他用户的程序。
- ps -A	显示所有程序。
- kill [pid]	杀死特定进程 （eg：kill －9 324，-9为强制杀死）

### 查看CPU型号,内存大小,硬盘空间的命令

1. uname -a # 查看内核/操作系统/CPU信息的linux系统信息 
2. head -n l /etc/issue # 查看操作系统版本 
3. cat /proc/cpuinfo # 查看CPU信息 
4. hostname # 查看计算机名的linux系统信息命令 
5. lspci -tv # 列出所有PCI设备  
6. lsusb -tv # 列出所有USB设备的linux系统信息命令 
7. lsmod # 列出加载的内核模块  
8. env # 查看环境变量资源 
9. free -m # 查看内存使用量和交换区使用量  
10. df -h # 查看各分区使用情况 
11. du -sh # 查看指定目录的大小  
12. grep MemTotal /proc/meminfo # 查看内存总量 
13. grep MemFree /proc/meminfo # 查看空闲内存量  
14. uptime # 查看系统运行时间、用户数、负载 
15. cat /proc/loadavg # 查看系统负载磁盘和分区  
16. mount | column -t # 查看挂接的分区状态 
17. fdisk -l # 查看所有分区  
18. swapon -s # 查看所有交换分区 
19. hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)  
20. dmesg | grep IDE # 查看启动时IDE设备检测状况网络 
21. ifconfig # 查看所有网络接口的属性  
22. iptables -L # 查看防火墙设置 
23. route -n # 查看路由表  
24. netstat -lntp # 查看所有监听端口 
25. netstat -antp # 查看所有已经建立的连接  
26. netstat -s # 查看网络统计信息进程 
27. ps -ef # 查看所有进程  
28. top # 实时显示进程状态用户 
29. w # 查看活动用户  
30. id # 查看指定用户信息 
31. last # 查看用户登录日志  
32. cut -d: -f1 /etc/passwd # 查看系统所有用户 
33. cut -d: -f1 /etc/group # 查看系统所有组  
34. crontab -l # 查看当前用户的计划任务服务 
35. chkconfig –list # 列出所有系统服务  
36. chkconfig –list | grep on # 列出所有启动的系统服务程序 
37. rpm -qa # 查看所有安装的软件包  
38. cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令 
39. cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令  
40. cat /proc/meminfo ：查看linux系统内存信息的linux系统命令 
41. cat /proc/version ：查看版本，类似uname -r  
42. cat /proc/ioports ：查看设备io端口 
43. cat /proc/interrupts ：查看中断  
44. cat /proc/pci ：查看pci设备的信息 
45. cat /proc/swaps ：查看所有swap分区的信息  

### 使用swap创建临时分区

```bash
# count的大小就是增加的swap空间的大小，64M是块大小，所以空间大小是bs*count=1024MB
sudo dd if=/dev/zero of=/tmp/mem.swap bs=64M count=16

 # 查看当前分区大小
 free -m
 
 # 格式转换并挂载
 sudo mkswap /tmp/mem.swap
 sudo swapon /tmp/mem.swap
 
 # 确认是否增加成功
 free -m
 
 # 用完后关闭临时空间
 swapoff -a

```

