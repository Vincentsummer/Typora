# linux操作系统学习

## 源码结构

linux系统下，内核源代码一般在/usr/src/linux目录下。

- arch 包含了此核心源代码所支持的硬件体系结构相关的核心代码。如对于X86平台就是i386。
- include 包括了核心的大多数include文件。另外对于每种支持的体系结构分别有一个子目录。
- init 包含核心启动代码。
- mm 包含了所有的内存管理代码。与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下，如对应于X86的就是arch/i386/mm/fault.c 。
- drivers 系统中所有的设备驱动都位于此目录中。它又进一步划分成几类设备驱动，每一种也有对应的子目录，如声卡的驱动对应于drivers/sound。
- ipc 包含了核心的进程间通讯代码。
- modules 包含已建好可动态加载的模块。
- fs Linux支持的文件系统代码。不同的文件系统有不同的子目录对应，如ext2文件系统对应的就是ext2子目录。
- kernel 主要核心代码。同时与处理器结构相关代码都放在arch/*/kernel目录下。
- net 核心的网络部分代码。里面的每个子目录对应于网络的一个方面。
- lib 包含了核心的库代码。与处理器结构相关库代码被放在arch/*/lib/目录下。
- scripts 包含用于配置核心的脚本文件。
- Documentation 参考文档。

## 文件IO

文件I/O通常为不带缓冲的I/O。大多数文件I/O只需用到5个函数：*open、read、write、lseek*以及*close*。

### 文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开或创建一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。

### 函数open和openat

调用*open*或*openat*函数可以打开或创建一个文件。

```c
#include <fcntl.h>

int open(const char *path, int oflag, ... /*mode_t mode */);
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
//return : 文件描述符 or -1
```

### 函数create

调用*creat*函数创建一个新文件*。

```c
#include <fnctl.h>

int creat(const char *path, mode_t mode);
//return: 只写打开的文件描述符 or -1
```

此函数等效于*open(path, O_WRITELY | O_CREAT | O_TRUNC, mode)*;

### 函数close

可调用*close*函数关闭一个打开的文件。

```c
#include <unistd.h>

int close(int fd);
//return : 0 or -1
```

### 函数lseek

每个打开的文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读写都从当前的文件偏移量处开始，并使偏移量增加所读写的字节数。

可调用*lseek*函数显式地为一个打开文件设置偏移量。

```c
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
// return : 新的文件偏移量 or -1
```

### 函数read

调用read函数从打开文件中读数据。

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);
// return : 读到的字节数；若已到文件尾，返回0；出错返回-1.
```

### 函数write

调用*write*函数向打开文件写数据。

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t nbytes);
// return : 已写字节数 or -1
```

### 函数pread和pwrite

*pread*函数和*pwrite*函数允许原子性地定位并执行I/O。

```c
#include <unistd.h>

ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
// return : 读到的字节数；若已到文件尾，返回0；出错返回-1。
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
// return : 已写的字节数 or -1
```

### 函数dup与dup2

*dup*函数与*dup2*函数用来复制一个现有的文件描述符。

```c
#include <unistd.h>

int dup(int fd);
int dup2(int fd, int fd2);
//return : 新的文件描述符 or -1
```

### 函数sync、fsync和fdatasync

上述三个函数将缓冲区中的数据同步到磁盘中。

```c
# include <unistd.h>

int fsync(int fd);
int fdatasync(int fd);
// return : 0 or -1
int sync(void);
```

*sync*函数将所有修改过的块缓冲区排入写队列，然后返回，并不等待实际写磁盘操作结束。

*fsync*函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。

*fdatasync*函数类似于*fsync*函数，但它只影响文件的数据部分。而*fsync*函数还会同步更新文件的属性。

### 函数fcntl

*fcntl*函数可以改变已经打开文件的属性。

```c
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* int arg */);
```

## 标准IO库

### 流和FILE对象

Linux中的标准IO库对文件的操作围绕**流**进行。当使用其打开或创建一个文件时，会使一个流与一个文件相关联。

使用以下函数可以获得一个流的描述符。

```c
#include <stdio.h>
int fileno(FILE *fp);
```

流的定向决定所读、写的字符是单字节还是多字节。一个流最初被创建时，其状态为未定向。

- 宽定向：在一个未定向流上使用一个多字节I/O函数，则将该流设置为宽定向。
- 字节定向：在一个未定向流上使用一个单字节I/O函数，则将该流设置为字节定向。

仅有两个函数可改变流的定向。*freopen*函数清除一个流的定向；*fwide*函数设置流的定向。*fwide*函数并不改变已定向流的定向，且无出错返回。

```c
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fd, int mode);
//return : >0 if 宽定向，<0 if 字节定向， 0 if 未定向
```

*fopen*函数用于打开一个流，并返回一个指向FILE对象的指针。该对象包含了标准IO库为管理该流需要的所有信息。包括文件描述符、指向用于该流的缓冲区的指针、缓冲区长度、当前在缓冲区中的字符以及出错标志等。

### 标准输入、标准输出和标准错误

对一个进程预定义3个流，其引用的文件与文件描述符STDIN_FILENO、SYDOUT_FILENO和STDERR_FILENO所引用的相同。并通过预定义文件指针stdin、stdout和stderr加以引用。

### 缓冲

提供缓冲的目的在于尽可能减少使用read和write的次数。同时它也为每个I/O流自动地进行缓冲管理。标准I/O库提供了3种类型的缓冲：

1. 全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对磁盘上的文件通常采用全缓冲。在一个流上执行第一次操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。缓冲区可自动冲洗（当填满一个缓冲区时），或者调用函数fflush冲洗一个流。flush（冲洗）将缓冲区中的内容写到磁盘上。
2. 行缓冲。当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。当流涉及一个终端时，通常使用行缓冲。
3. 不带缓冲。不对字符进行缓冲存储。stderr通常为不带缓冲流。

可使用*setbuf*和*setvbuf*更改缓冲类型。

```c
#include <stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
// return: 0 if success, !0 if fail.
int fflush(FILE *fp);
//return: 0 if success, EOF if fail.
```

### 打开流

下列3个函数打开一个标准I/O流。

```c
#include <stdio.h>

FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
// return FILE* or NULL
```

- *fopen*函数打开一个路径名为pathname的一个指定文件。
- *freopen*函数在一个指定流上打开一个指定的文件，若流已经打开，则先关闭流。若该流已定向，则清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：stdin、stdout或stderr。
- *fdopen*函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道或网络通信通道函数返回的描述符。

使用*fclose*函数关闭一个打开的流。

```c
#include <stdio.h>

int fclose(FILE *fp);
// return: 0 if success, EOF if fail.
```

在该文件被关闭之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据被丢弃。

当一个进程正常终止时（直接调用*exit*函数，或从*main*函数返回），则所有带未写缓冲数据的标准I/O流都被冲洗，所有打开的标准I/O流都被关闭。

### 读和写流

一个打开的流，可在3中不同类型的非格式化I/O中进行选择，对其进行读写操作。

1. 每次一个字符的I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。
2. 每次一行的I/O。使用*fgets*和*fputs*。每行都以一个换行符终止。
3. 直接I/O。*fread*和*fwrite*函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。常用于从二进制文件中每次读或写一个结构。

#### 输入函数

```c
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
// return: next char or EOF
```

*getchar*等同于*getc(stdin)*。*getc*可被实现为宏，*fgetc*不能实现为宏。

无论是出错还是达到文件尾，其返回相同的值。需使用以下两个函数进行区分。

```c
#include <stdio.h>

int ferror(FILE *fp);
int feof(FILE *fp);
// return: !0 or 0

void clearerr(FILE *fp);  // 清除标志（出错及文件结束标志）
```

从流中读取数据后，可调用*ungetc*将字符再压送回流中。

```c
#include <stdio.h>

int ungetc(int c, FILE *fp);
// return : c or EOF
```

#### 输出函数

对应上述3个输入函数有相同的输出函数。

```c
#include <stdio.h>

int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
//return: c or EOF
```

### 每次一行I/O

以下两个函数提供每次输入一行的功能。

```c
#include <stdio.h>

char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);
//return: buf or NULL
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
//return: >=0 or EOF
```

*gets*从标准输入读，不将换行符存入缓冲区；*fgets*则从指定的流读，并且将换行符存入缓冲区。*gets*不推荐使用，其没有指定缓冲区长度，可能造成缓冲区溢出。输出函数同理。

### 二进制I/O

使用下列两个函数执行二进制I/O操作。

```c
#include <stdio.h>

size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

// return : the number of object read/write 
```

### 定位流

有3种方法定位标准I/O流。

```c
#include <stdio.h>

long ftell(FILE *fp); 
// return: file current position if success, -1L if fail.
int fseek(FILE *fp, long offset, int whence);
// return : 0 if success, -1 if fail.

off_t ftello(FILE *fp);
// return : file current position if success, (off_t)-1 if fail.
int fseeko(FILE *fp, off_t offset, int whence);
// return : 0 if success, -1 if fail.

int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetops(FILE *fp, const fpos_t *pos);
// return : 0 if success, -1 if fail.
void rewind(FILE *fp);
```

### 格式化I/O

#### 格式化输入

格式化输出由5个函数来处理。

```c
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
//return : 成功：输出字节数， 出错返回负值。
int sprintf(char *restrict buf, const char *restrict format, ...);
//return : 成功：存入数组的字符数；出错返回负值。
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
//return : 或缓冲区足够大，返回将要存入数组的字符数；出错则返回负值。

```

下面5中printf族的变体类似于上面5种，但是将可变参数表（...）替换成了arg。

```c
#include <stdarg.h>
#include <stdio.h>
int vprintf(const char *restrict format, va_list arg);
int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
int vdprintf(int fd, const char *restrict format, va_list arg);
//return : 成功：输出字节数， 出错返回负值。
int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
//return : 成功：存入数组的字符数；出错返回负值。
int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);
//return : 或缓冲区足够大，返回将要存入数组的字符数；出错则返回负值。
```

#### 格式化输出

格式化输出由3个函数处理。

```c
#include <stdio.h>

int scanf(const char *restrict format, ...);
int fscanf(FILE *fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);
//return: 赋值的输入项数；若出错或在任一转换前已达到文件尾端，返回EOF。
```

同理还有一下变体。

```c
#include <stdarg.h>
#include <stdio.h>

int scanf(const char *restrict format, va_list arg);
int fscanf(FILE *fp, const char *restrict format, va_list arg);
int sscanf(const char *restrict buf, const char *restrict format, va_list arg);
//return: 赋值的输入项数；若出错或在任一转换前已达到文件尾端，返回EOF。
```



## Linux进程间通信

linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。如下图所示：

<img src="/home/vincent/Typora/Linux.assets/Linux1.png" style="zoom:67%;" />

linux下进程间通信的几种主要手段简介：

- 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
- 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
- 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
- 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
- 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

### IPC介绍

**进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间共享消息的一种通信方式**。消息(message)是发送进程形成的一个消息块，将消息内容传送给接收进程。IPC机制是消息从一个进程的地址空间拷贝到另一个进程的地址空间。

进程通信的目的：

- 数据传输
  一个进程需要将其数据发送给另一进程，发送的数据量在一个字节到几M字节之间。
- 共享数据
  多个进程操作共享数据。
- 事件通知
  一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- 资源共享
  多个进程之间共享同样的资源。**为了作到这一点，需要内核提供锁和同步机制**。
- 进程控制
  有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### linux使用的进程间通信方式

1. 管道（pipe）,流管道(s_pipe)和有名管道（FIFO）
2. 消息队列
3. **共享内存**
4. **信号量**
5. **套接字（socket)**

#### 管道（Pipe）

管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。

特点：

- 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
- 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

#### 命名管道（FIFO）

FIFO，也称为命名管道，它是一种文件类型。

在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。

特点：

- FIFO可以在无关的进程之间交换数据，与无名管道不同。
- FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

#### 消息队列（message queue）

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。 消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。

特点：

- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
- 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
- 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

#### 信号量（semaphore）

信号量与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

特点：

- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
- 支持信号量组。

#### 共享内存（Shared Memory）

共享内存，指两个或多个进程共享一个给定的存储区。

将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。

特点：

- 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
- 因为多个进程可以同时操作，所以需要进行同步。
- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

#### 套接字（socket）

套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

### 总结

#### 几种通信方式的比较

1. 管道：速度慢，容量有限，只有父子进程能通讯。
2. FIFO：任何进程间都能通讯，但速度慢。
3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
4. 信号量：不能传递复杂消息，只能用来同步。
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

#### 进程间通信方式的选择

- PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，**这两种方式通常适用于两个进程间的通信**。
- 共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于多进程间的通信。
- 其他考虑用socket。主要应用在**分布式开发中**。

一般来说，linux下的进程包含以下几个关键要素：

- 有一段可执行程序；

- 有专用的系统堆栈空间；

- 内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；

- 具有独立的存储空间。

进程和线程有时候并不完全区分，而往往根据上下文理解其含义。

## 用户态与内核态

在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。Intel的CPU将特权级别分为4个级别：RING0，RING1，RING2，RING3。

linux的内核是一个有机的整体。每一个用户进程运行时都好像有一份内核的拷贝，每当用户进程使用系统调用时，都自动地将运行模式从用户级转为内核级，此时进程在内核的地址空间中运行。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, 如上所提到的intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。

![内核态](Linux.assets/内核态.gif)

**操作系统需要两种CPU状态：**

- 内核态（Kernel Mode）：运行操作系统程序。

- 用户态（User Mode）：运行用户程序。

**指令划分：**

- 特权指令：只能由操作系统使用、用户程序不能使用的指令。  eg：启动I/O，内存清零，修改程序状态字，设置时钟，允许/禁止终端，停机。

- 非特权指令：用户程序可以使用的指令。  eg：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）。

**特权级别：**

- **特权环：R0、R1、R2和R3**。R0相当于内核态，R3相当于用户态；不同级别能够运行不同的指令集合；

**CPU状态之间的转换：**

- **用户态--->内核态：**唯一途径是通过中断、异常、陷入机制（访管指令）。

- **内核态--->用户态：**设置程序状态字PSW。

**用户态到内核态的切换：**

- 系统调用

**这是用户态进程主动要求切换到内核态的一种方式**，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

- 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 

- 外围设备的中断

**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

## 进程与线程

#### 进程

**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。**进程是一种抽象的概念，从来没有统一的标准定义。**进程一般由程序，数据集合和进程控制块三部分组成**。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志。

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

- 并发性：任何进程都可以同其他进行一起并发执行；

- 独立性：进程是系统进行资源分配和调度的一个独立单位；

- 结构性：进程由程序，数据和进程控制块三部分组成。

#### 线程

在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

#### 进程与线程的区别

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多。

#### 为何不使用多进程而是使用多线程？

线程廉价，线程启动比较快，退出比较快，对系统资源的冲击也比较小。而且线程彼此分享了大部分核心对象(File Handle)的拥有权如果使用多重进程，但是不可预期，且测试困难。

#### 进程调度策略

**先来先服务调度算法**

先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

**短作业(进程)优先调度算法**

短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

**高优先权优先调度算法**

为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。

- **非抢占式优先权算法**：在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。
- **抢占式优先权调度算法**：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程 $i$ 时，就将其优先权 $P_i$ 与正在执行的进程 $j$ 的优先权 $P_j$ 进行比较。如果 $P_i≤P_j$，原进程 $P_j$ 便继续执行；但如果是 $P_i>P_j$，则立即停止 $P_j$ 的执行，做进程切换，使 $i$ 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

优先级倒置现象：优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。

优先级反转案例解释：不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。

优先级倒置解决方案：

- 设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。
- 优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。
- 临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。

**高响应比优先调度算法**

在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 $a$ 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。 在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。

**时间片轮转法**

在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。

**多级反馈队列调度算法**

前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。

1. 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。
2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。
3. 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

#### 批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？

- 批处理系统常用调度算法：先来先服务，最短作业优先，最短剩余时间优先，响应比最高者优先。
- 分时系统调度算法：轮转调度，优先级调度，多级队列调度，彩票调度。
- 实时系统调度算法：单比率调度，限期调度，最少裕度法。

## linux常用命令总结（Ubuntu）

### 常用软件更新命令

- apt-get install package 安装package
- apt-get install package --reinstall 重新安装包package
- apt-get -f install 修复安装
- apt-get update 更新源
- apt-get upgrade 更新已安装的包
- apt-get dist-upgrade 升级系统
- apt-get remove package 删除包
- apt-get remove package --purge 删除包，包括配置文件等
- apt-get clean 清理所有软件缓存
- sudo apt-get autoclean 清理旧版本软件缓存
- sudo apt-get autoremove 清理系统不再使用的孤立软件

### 查看Ubuntu系统版本信息

- cat /proc/version	查看linux内核、gcc编译器和Ubuntu版本号
- uname -a	显示linux的内核版本和系统位数
- lsb_release -a	查看ubuntu发行版本号
- dpkg --get-selections|grep linux 查看当前系统所有内核
- sudo apt-get remove 【内核名】删除内核

### 进程相关命令

- ps [pid]	查看进程（特定pid的进程）
- ps a	显示现行终端机下的所有程序，包括其他用户的程序。
- ps -A	显示所有程序。
- kill [pid]	杀死特定进程 （eg：kill －9 324，-9为强制杀死）

### 查看CPU型号,内存大小,硬盘空间的命令

1. uname -a # 查看内核/操作系统/CPU信息的linux系统信息 
2. head -n l /etc/issue # 查看操作系统版本 
3. cat /proc/cpuinfo # 查看CPU信息 
4. hostname # 查看计算机名的linux系统信息命令 
5. lspci -tv # 列出所有PCI设备  
6. lsusb -tv # 列出所有USB设备的linux系统信息命令 
7. lsmod # 列出加载的内核模块  
8. env # 查看环境变量资源 
9. free -m # 查看内存使用量和交换区使用量  
10. df -h # 查看各分区使用情况 
11. du -sh # 查看指定目录的大小  
12. grep MemTotal /proc/meminfo # 查看内存总量 
13. grep MemFree /proc/meminfo # 查看空闲内存量  
14. uptime # 查看系统运行时间、用户数、负载 
15. cat /proc/loadavg # 查看系统负载磁盘和分区  
16. mount | column -t # 查看挂接的分区状态 
17. fdisk -l # 查看所有分区  
18. swapon -s # 查看所有交换分区 
19. hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)  
20. dmesg | grep IDE # 查看启动时IDE设备检测状况网络 
21. ifconfig # 查看所有网络接口的属性  
22. iptables -L # 查看防火墙设置 
23. route -n # 查看路由表  
24. netstat -lntp # 查看所有监听端口 
25. netstat -antp # 查看所有已经建立的连接  
26. netstat -s # 查看网络统计信息进程 
27. ps -ef # 查看所有进程  
28. top # 实时显示进程状态用户 
29. w # 查看活动用户  
30. id # 查看指定用户信息 
31. last # 查看用户登录日志  
32. cut -d: -f1 /etc/passwd # 查看系统所有用户 
33. cut -d: -f1 /etc/group # 查看系统所有组  
34. crontab -l # 查看当前用户的计划任务服务 
35. chkconfig –list # 列出所有系统服务  
36. chkconfig –list | grep on # 列出所有启动的系统服务程序 
37. rpm -qa # 查看所有安装的软件包  
38. cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令 
39. cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令  
40. cat /proc/meminfo ：查看linux系统内存信息的linux系统命令 
41. cat /proc/version ：查看版本，类似uname -r  
42. cat /proc/ioports ：查看设备io端口 
43. cat /proc/interrupts ：查看中断  
44. cat /proc/pci ：查看pci设备的信息 
45. cat /proc/swaps ：查看所有swap分区的信息  

### 使用swap创建临时分区

```bash
# count的大小就是增加的swap空间的大小，64M是块大小，所以空间大小是bs*count=1024MB
sudo dd if=/dev/zero of=/tmp/mem.swap bs=64M count=16

 # 查看当前分区大小
 free -m
 
 # 格式转换并挂载
 sudo mkswap /tmp/mem.swap
 sudo swapon /tmp/mem.swap
 
 # 确认是否增加成功
 free -m
 
 # 用完后关闭临时空间
 swapoff -a

```

## 问题

### read系统调用与标准I/O库fread

